[akka.actor.deployment.default]
# if this is set to a valid remote address, the named actor will be
# deployed at that node e.g. "akka://sys@host:port"
remote = ""

[akka.actor.deployment.default.target]
# A list of hostnames and ports for instantiating the children of a
# router
#   The format should be on "akka://sys@host:port", where:
#    - sys is the remote actor system name
#    - hostname can be either hostname or IP address the remote actor
#      should connect to
#    - port should be the port for the remote server on the other node
# The number of actor instances to be spawned is still taken from the
# nr-of-instances setting as for local routers; the instances will be
# distributed round-robin among the given nodes.
nodes = []

[akka.remote]
# Using remoting directly is typically not desirable, so a warning will
# be shown to make this clear. Set this setting to 'off' to suppress that
# warning.
warn-about-direct-use = true

# If Cluster is not used, remote watch and deployment are disabled.
# To optionally use them while not using Cluster, set to 'on'.
use-unsafe-remote-features-outside-cluster = false

# A warning will be logged on remote watch attempts if Cluster
# is not in use and 'use-unsafe-remote-features-outside-cluster'
# is 'off'. Set this to 'off' to suppress these.
warn-unsafe-watch-outside-cluster = true

# Settings for the Phi accrual failure detector (http://www.jaist.ac.jp/~defago/files/pdf/IS_RR_2004_010.pdf
# [Hayashibara et al]) used for remote death watch.
# The default PhiAccrualFailureDetector will trigger if there are no heartbeats within
# the duration heartbeat-interval + acceptable-heartbeat-pause + threshold_adjustment,
# i.e. around 12.5 seconds with default settings.
[akka.remote.watch-failure-detector]
# FQCN of the failure detector implementation.
# It must implement akka.remote.FailureDetector and have
# a public constructor with a com.typesafe.config.Config and
# akka.actor.EventStream parameter.
implementation-class = "akka.remote.PhiAccrualFailureDetector"

# How often keep-alive heartbeat messages should be sent to each connection.
heartbeat-interval = { secs = 1, nanos = 0 }

# Defines the failure detector threshold.
# A low threshold is prone to generate many wrong suspicions but ensures
# a quick detection in the event of a real crash. Conversely, a high
# threshold generates fewer mistakes but needs more time to detect
# actual crashes.
threshold = 10.0

# Number of the samples of inter-heartbeat arrival times to adaptively
# calculate the failure timeout for connections.
max-sample-size = 200

# Minimum standard deviation to use for the normal distribution in
# AccrualFailureDetector. Too low standard deviation might result in
# too much sensitivity for sudden, but normal, deviations in heartbeat
# inter arrival times.
min-std-deviation = { secs = 0, nanos = 100000 }

# Number of potentially lost/delayed heartbeats that will be
# accepted before considering it to be an anomaly.
# This margin is important to be able to survive sudden, occasional,
# pauses in heartbeat arrivals, due to for example garbage collect or
# network drop.
acceptable-heartbeat-pause = { secs = 10, nanos = 0 }


# How often to check for nodes marked as unreachable by the failure
# detector
unreachable-nodes-reaper-interval = { secs = 1, nanos = 0 }

# After the heartbeat request has been sent the first failure detection
# will start after this period, even though no heartbeat mesage has
# been received.
expected-response-after = { secs = 1, nanos = 0 }

[akka.remote.deployment]
# If true, will only allow specific classes listed in `allowed-actor-classes` to be instanciated on this
# system via remote deployment
enable-allow-list = false

allowed-actor-classes = []

[akka.remote.artery]
# This flag disabled Artery in Akka 2.6.x and 2.7.x. If it is set to off with Akka 2.8.0 or later
# an exception will be thrown at startup with the purpose to notify the user that Classic Remoting
# has been removed.
enabled = true

# Select the underlying transport implementation.
#
# Possible values: aeron-udp, tcp, tls-tcp
# See https://doc.akka.io/docs/akka/current/remoting-artery.html#selecting-a-transport for the tradeoffs
# for each transport
transport = "tcp"

# Actor paths to use the large message stream for when a message
# is sent to them over remoting. The large message stream dedicated
# is separate from "normal" and system messages so that sending a
# large message does not interfere with them.
# Entries should be the full path to the actor. Wildcards in the form of "*"
# can be supplied at any place and matches any name at that segment -
# "/user/supervisor/actor/*" will match any direct child to actor,
# while "/supervisor/*/child" will match any grandchild to "supervisor" that
# has the name "child"
# Entries have to be specified on both the sending and receiving side.
# Messages sent to ActorSelections will not be passed through the large message
# stream, to pass such messages through the large message stream the selections
# but must be resolved to ActorRefs first.
large-message-destinations = []

# Enable untrusted mode, which discards inbound system messages, PossiblyHarmful and
# ActorSelection messages. E.g. remote watch and remote deployment will not work.
# ActorSelection messages can be enabled for specific paths with the trusted-selection-paths
untrusted-mode = false

# When 'untrusted-mode=on' inbound actor selections are by default discarded.
# Actors with paths defined in this list are granted permission to receive actor
# selections messages.
# E.g. trusted-selection-paths = ["/user/receptionist", "/user/namingService"]
trusted-selection-paths = []

# If this is "on", all inbound remote messages will be logged at DEBUG level,
# if off then they are not logged
log-received-messages = false

# If this is "on", all outbound remote messages will be logged at DEBUG level,
# if off then they are not logged
log-sent-messages = false

# Logging of message types with payload size in bytes larger than
# this value. Maximum detected size per message type is logged once,
# with an increase threshold of 10%.
# By default this feature is turned off. Activate it by setting the property to
# a value in bytes, such as 1000b. Note that for all messages larger than this
# limit there will be extra performance and scalability cost.
log-frame-size-exceeding = false

# Canonical address is the address other clients should connect to.
# Artery transport will expect messages to this address.
[akka.remote.artery.canonical]
# The default remote server port clients should connect to.
# Default is 25520, use 0 if you want a random available port
# This port needs to be unique for each actor system on the same machine.
port = 25520

# Hostname clients should connect to. Can be set to an ip, hostname
# or one of the following special values:
#   "<getHostAddress>"   InetAddress.getLocalHost.getHostAddress
#   "<getHostName>"      InetAddress.getLocalHost.getHostName
#
hostname = "<getHostAddress>"

# Use these settings to bind a network interface to a different address
# than artery expects messages at. This may be used when running Akka
# nodes in a separated networks (under NATs or in containers). If canonical
# and bind addresses are different, then network configuration that relays
# communications from canonical to bind addresses is expected.
[akka.remote.artery.bind]
# Port to bind a network interface to. Can be set to a port number
# of one of the following special values:
#   0    random available port
#   ""   akka.remote.artery.canonical.port
#
port = ""

# Hostname to bind a network interface to. Can be set to an ip, hostname
# or one of the following special values:
#   "0.0.0.0"            all interfaces
#   ""                   akka.remote.artery.canonical.hostname
#   "<getHostAddress>"   InetAddress.getLocalHost.getHostAddress
#   "<getHostName>"      InetAddress.getLocalHost.getHostName
#
hostname = ""

# Time to wait for Aeron/TCP to bind
bind-timeout = { secs = 3, nanos = 0 }